import { Connector, WebRTCParams } from "./inference-api";
import { WebRTCOutputData, WebRTCHooks } from "./webrtc-types";
export type { WebRTCVideoMetadata, WebRTCOutputData, WebRTCHooks } from "./webrtc-types";
export { FileUploader } from "./video-upload";
/**
 * Reassembles chunked binary messages from the datachannel
 */
export declare class ChunkReassembler {
    private pendingFrames;
    /**
     * Process an incoming chunk and return the complete message if all chunks received
     */
    processChunk(frameId: number, chunkIndex: number, totalChunks: number, payload: Uint8Array): Uint8Array | null;
    /**
     * Clear all pending frames (for cleanup)
     */
    clear(): void;
}
/**
 * Parse the binary header from a datachannel message
 */
export declare function parseBinaryHeader(buffer: ArrayBuffer): {
    frameId: number;
    chunkIndex: number;
    totalChunks: number;
    payload: Uint8Array;
};
export interface UseStreamOptions {
    disableInputStreamDownscaling?: boolean;
}
export interface UseStreamParams {
    source: MediaStream;
    connector: Connector;
    wrtcParams: WebRTCParams;
    onData?: (data: WebRTCOutputData) => void;
    options?: UseStreamOptions;
    /** Lifecycle hooks for customizing WebRTC behavior */
    hooks?: WebRTCHooks;
}
/**
 * WebRTC Connection object
 *
 * Represents an active WebRTC connection to Roboflow for streaming inference
 * or file-based batch processing.
 */
export declare class RFWebRTCConnection {
    /**
     * The underlying RTCPeerConnection.
     * Exposed for advanced use cases like getting stats or accessing senders.
     */
    readonly peerConnection: RTCPeerConnection;
    private _localStream?;
    private remoteStreamPromise;
    private pipelineId;
    private apiKey;
    /**
     * The data channel used for receiving inference results.
     * Exposed for advanced use cases.
     */
    readonly dataChannel: RTCDataChannel;
    private reassembler;
    private ackPacingEnabled;
    /**
     * The data channel used for uploading video files (only available in file upload mode).
     * Exposed for advanced use cases.
     */
    readonly uploadChannel?: RTCDataChannel;
    private uploader?;
    private onComplete?;
    /** @private */
    constructor(pc: RTCPeerConnection, remoteStreamPromise: Promise<MediaStream>, pipelineId: string | null, apiKey: string | null, dataChannel: RTCDataChannel, options?: {
        localStream?: MediaStream;
        uploadChannel?: RTCDataChannel;
        onData?: (data: any) => void;
        onComplete?: () => void;
        /** @internal Enable server pacing via cumulative ACKs (only used when realtimeProcessing=false). */
        ackPacingEnabled?: boolean;
    });
    /**
     * Send cumulative ACK after a frame is fully handled.
     * Only used in batch mode (realtimeProcessing=false).
     */
    private maybeSendAck;
    /**
     * Get the remote stream (processed video from Roboflow)
     *
     * @returns Promise resolving to the remote MediaStream
     *
     * @example
     * ```typescript
     * const conn = await useStream({ ... });
     * const remoteStream = await conn.remoteStream();
     * videoElement.srcObject = remoteStream;
     * ```
     */
    remoteStream(): Promise<MediaStream>;
    /**
     * Get the local stream (original camera)
     *
     * @returns The local MediaStream, or undefined if using file upload mode
     *
     * @example
     * ```typescript
     * const conn = await useStream({ ... });
     * const localStream = conn.localStream();
     * if (localStream) {
     *   videoElement.srcObject = localStream;
     * }
     * ```
     */
    localStream(): MediaStream | undefined;
    /**
     * Cleanup and close connection
     *
     * Terminates the pipeline on Roboflow, closes the peer connection,
     * and stops the local media stream (if applicable).
     *
     * @returns Promise that resolves when cleanup is complete
     *
     * @example
     * ```typescript
     * const conn = await useStream({ ... });
     * // ... use connection ...
     * await conn.cleanup(); // Clean up when done
     * ```
     */
    cleanup(): Promise<void>;
    /**
     * Start uploading a file through the connection
     *
     * @param file - The file to upload
     * @param onProgress - Optional callback for progress updates (bytesUploaded, totalBytes)
     * @returns Promise that resolves when upload is complete
     * @throws Error if no upload channel is available
     *
     * @example
     * ```typescript
     * await connection.startUpload(videoFile, (uploaded, total) => {
     *   console.log(`Upload progress: ${(uploaded / total * 100).toFixed(1)}%`);
     * });
     * ```
     */
    startUpload(file: File, onProgress?: (bytesUploaded: number, totalBytes: number) => void): Promise<void>;
    /**
     * Cancel any ongoing file upload
     */
    cancelUpload(): void;
    /**
     * Reconfigure pipeline outputs at runtime
     *
     * Dynamically change stream and data outputs without restarting the connection.
     * Set a field to `null` to leave it unchanged, or to `null` value to enable all outputs,
     * or to `[]` to disable/auto-detect.
     *
     * @param config - Output configuration
     * @param config.streamOutput - Stream output names (null = unchanged, [] = auto-detect, ["name"] = specific output)
     * @param config.dataOutput - Data output names (null = unchanged, [] = disable, ["name"] = specific outputs, null value = all outputs)
     *
     * @example
     * ```typescript
     * // Change to different stream output
     * connection.reconfigureOutputs({
     *   streamOutput: ["annotated_image"],
     *   dataOutput: null  // unchanged
     * });
     *
     * // Enable all data outputs
     * connection.reconfigureOutputs({
     *   streamOutput: null,  // unchanged
     *   dataOutput: null     // null value = all outputs
     * });
     *
     * // Disable all data outputs
     * connection.reconfigureOutputs({
     *   streamOutput: null,  // unchanged
     *   dataOutput: []       // empty array = disable
     * });
     * ```
     */
    reconfigureOutputs(config: {
        streamOutput?: string[] | null;
        dataOutput?: string[] | null;
    }): void;
    /**
     * Send data through the data channel
     * @private
     */
    private sendData;
}
/**
 * Main function to establish WebRTC streaming connection
 *
 * Creates a WebRTC connection to Roboflow for real-time inference on video streams.
 *
 * @param params - Connection parameters
 * @returns Promise resolving to RFWebRTCConnection
 *
 * @example
 * ```typescript
 * import { useStream } from 'inferencejs/webrtc';
 * import { connectors } from 'inferencejs/api';
 * import { useCamera } from 'inferencejs/streams';
 *
 * const connector = connectors.withApiKey("your-api-key");
 * const stream = await useCamera({ video: { facingMode: { ideal: "environment" } } });
 * const conn = await useStream({
 *   source: stream,
 *   connector,
 *   wrtcParams: {
 *     workflowSpec: {
 *       // Your workflow specification
 *     },
 *     imageInputName: "image",
 *     streamOutputNames: ["output"],
 *     dataOutputNames: ["predictions"]
 *   },
 *   onData: (data) => {
 *     console.log("Inference results:", data);
 *   }
 * });
 *
 * const remoteStream = await conn.remoteStream();
 * videoElement.srcObject = remoteStream;
 * ```
 */
export declare function useStream({ source, connector, wrtcParams, onData, options, hooks }: UseStreamParams): Promise<RFWebRTCConnection>;
/**
 * Parameters for useVideoFile function
 */
export interface UseVideoFileParams {
    /** The video file to upload */
    file: File;
    /** Connector for WebRTC signaling */
    connector: Connector;
    /** WebRTC parameters for the workflow */
    wrtcParams: WebRTCParams;
    /** Callback for inference results */
    onData?: (data: WebRTCOutputData) => void;
    /** Callback for upload progress */
    onUploadProgress?: (bytesUploaded: number, totalBytes: number) => void;
    /** Callback when processing completes (datachannel closes) */
    onComplete?: () => void;
    /** Lifecycle hooks for customizing WebRTC behavior */
    hooks?: WebRTCHooks;
}
/**
 * Upload a video file for batch inference processing
 *
 * Creates a WebRTC connection to Roboflow for uploading a video file
 * and receiving inference results. The file is uploaded via datachannel
 * with intelligent backpressure handling.
 *
 * @param params - Connection parameters
 * @returns Promise resolving to RFWebRTCConnection
 *
 * @example
 * ```typescript
 * import { connectors, webrtc } from './index.ts';
 *
 * const connector = connectors.withApiKey("your-api-key");
 * const connection = await webrtc.useVideoFile({
 *   file: videoFile,
 *   connector,
 *   wrtcParams: {
 *     workflowSpec: { ... },
 *     imageInputName: "image",
 *     dataOutputNames: ["predictions"]
 *   },
 *   onData: (data) => {
 *     console.log("Inference results:", data);
 *     if (data.processing_complete) {
 *       console.log("Processing complete!");
 *     }
 *   },
 *   onUploadProgress: (uploaded, total) => {
 *     console.log(`Upload: ${(uploaded / total * 100).toFixed(1)}%`);
 *   }
 * });
 *
 * // When done
 * await connection.cleanup();
 * ```
 */
export declare function useVideoFile({ file, connector, wrtcParams, onData, onUploadProgress, onComplete, hooks }: UseVideoFileParams): Promise<RFWebRTCConnection>;
/**
 * Parameters for useRtspStream function
 */
export interface UseRtspStreamParams {
    /** RTSP URL for server-side video capture (e.g., "rtsp://camera.local/stream") */
    rtspUrl: string;
    /** Connector for WebRTC signaling */
    connector: Connector;
    /** WebRTC parameters for the workflow */
    wrtcParams: WebRTCParams;
    /** Callback for inference results */
    onData?: (data: WebRTCOutputData) => void;
    /** Lifecycle hooks for customizing WebRTC behavior */
    hooks?: WebRTCHooks;
}
/**
 * Connect to an RTSP stream for inference processing
 *
 * Creates a WebRTC connection where the server captures video from an RTSP URL
 * and sends processed video back to the client. This is a receive-only mode -
 * no video is sent from the browser to the server.
 *
 * @param params - Connection parameters
 * @returns Promise resolving to RFWebRTCConnection
 *
 * @example
 * ```typescript
 * import { connectors, webrtc } from './index.ts';
 *
 * const connector = connectors.withApiKey("your-api-key");
 * const connection = await webrtc.useRtspStream({
 *   rtspUrl: "rtsp://camera.local/stream",
 *   connector,
 *   wrtcParams: {
 *     workflowSpec: { ... },
 *     imageInputName: "image",
 *     dataOutputNames: ["predictions"]
 *   },
 *   onData: (data) => {
 *     console.log("Inference results:", data);
 *   }
 * });
 *
 * // Get processed video stream from server
 * const remoteStream = await connection.remoteStream();
 * videoElement.srcObject = remoteStream;
 *
 * // When done
 * await connection.cleanup();
 * ```
 */
export declare function useRtspStream({ rtspUrl, connector, wrtcParams, onData, hooks }: UseRtspStreamParams): Promise<RFWebRTCConnection>;
//# sourceMappingURL=webrtc.d.ts.map