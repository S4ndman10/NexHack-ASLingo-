(function(h,w){typeof exports=="object"&&typeof module<"u"?w(exports):typeof define=="function"&&define.amd?define(["exports"],w):(h=typeof globalThis<"u"?globalThis:h||self,w(h.RoboflowClient={}))})(this,function(h){"use strict";var oe=Object.defineProperty;var se=(h,w,_)=>w in h?oe(h,w,{enumerable:!0,configurable:!0,writable:!0,value:_}):h[w]=_;var l=(h,w,_)=>se(h,typeof w!="symbol"?w+"":w,_);var A;const w=typeof process<"u"&&((A=process.env)!=null&&A.RF_API_BASE_URL)?process.env.RF_API_BASE_URL:"https://api.roboflow.com",_=["https://serverless.roboflow.com","https://serverless.roboflow.one"];class T{constructor(e,t="https://serverless.roboflow.com",r=w){l(this,"apiKey");l(this,"serverUrl");l(this,"apiBaseUrl");this.apiKey=e,this.serverUrl=t,this.apiBaseUrl=r}static init({apiKey:e,serverUrl:t,apiBaseUrl:r}){if(!e)throw new Error("apiKey is required");return new T(e,t,r)}async initializeWebrtcWorker({offer:e,workflowSpec:t,workspaceName:r,workflowId:a,config:o={}}){if(!e||!e.sdp||!e.type)throw new Error("offer with sdp and type is required");const i=!!t,f=!!(r&&a);if(!i&&!f)throw new Error("Either workflowSpec OR (workspaceName + workflowId) is required");if(i&&f)throw new Error("Provide either workflowSpec OR (workspaceName + workflowId), not both");const{imageInputName:d="image",streamOutputNames:c=[],dataOutputNames:s=[],threadPoolWorkers:C=4,workflowsParameters:v={},iceServers:m,processingTimeout:u,requestedPlan:p,requestedRegion:R,realtimeProcessing:P=!0,rtspUrl:E}=o,b={type:"WorkflowConfiguration",image_input_name:d,workflows_parameters:v,workflows_thread_pool_workers:C,cancel_thread_pool_tasks_on_exit:!0,video_metadata_input_name:"video_metadata"};i?b.workflow_specification=t:(b.workspace_name=r,b.workflow_id=a);const g={workflow_configuration:b,api_key:this.apiKey,webrtc_realtime_processing:P,webrtc_offer:{sdp:e.sdp,type:e.type},webrtc_config:m?{iceServers:m}:null,stream_output:c,data_output:s};u!==void 0&&(g.processing_timeout=u),p!==void 0&&(g.requested_plan=p),R!==void 0&&(g.requested_region=R),E&&(g.rtsp_url=E);const y=await fetch(`${this.serverUrl}/initialise_webrtc_worker`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(g)});if(!y.ok){const W=await y.text().catch(()=>"");throw new Error(`initialise_webrtc_worker failed (${y.status}): ${W}`)}return await y.json()}async terminatePipeline({pipelineId:e}){if(!e)throw new Error("pipelineId is required");await fetch(`${this.serverUrl}/inference_pipelines/${e}/terminate?api_key=${this.apiKey}`,{method:"POST",headers:{"Content-Type":"application/json"}})}async fetchTurnConfig(){if(!_.includes(this.serverUrl))return null;try{const e=await fetch(`${this.apiBaseUrl}/webrtc_turn_config?api_key=${this.apiKey}`,{method:"GET",headers:{"Content-Type":"application/json"}});if(!e.ok)return console.warn(`[RFWebRTC] Failed to fetch TURN config (${e.status}), using defaults`),null;const t=await e.json();let r;if(Array.isArray(t))r=t;else if(t.iceServers&&Array.isArray(t.iceServers))r=t.iceServers;else if(t.urls)r=[t];else return console.warn("[RFWebRTC] Invalid TURN config format, using defaults"),null;return r.map(o=>({urls:Array.isArray(o.urls)?o.urls:[o.urls],username:o.username,credential:o.credential}))}catch(e){return console.warn("[RFWebRTC] Error fetching TURN config:",e),null}}}const K={withApiKey(n,e={}){const{serverUrl:t,apiBaseUrl:r}=e;typeof window<"u"&&console.warn("[Security Warning] Using API key directly in browser will expose it. Use connectors.withProxyUrl() for production. See: https://docs.roboflow.com/api-reference/authentication#securing-your-api-key");const a=T.init({apiKey:n,serverUrl:t,apiBaseUrl:r});return{connectWrtc:async(o,i)=>(console.debug("wrtcParams",i),await a.initializeWebrtcWorker({offer:o,workflowSpec:i.workflowSpec,workspaceName:i.workspaceName,workflowId:i.workflowId,config:{imageInputName:i.imageInputName,streamOutputNames:i.streamOutputNames,dataOutputNames:i.dataOutputNames,threadPoolWorkers:i.threadPoolWorkers,workflowsParameters:i.workflowsParameters,iceServers:i.iceServers,processingTimeout:i.processingTimeout,requestedPlan:i.requestedPlan,requestedRegion:i.requestedRegion,realtimeProcessing:i.realtimeProcessing,rtspUrl:i.rtspUrl}})),getIceServers:async()=>await a.fetchTurnConfig(),_apiKey:n,_serverUrl:t}},withProxyUrl(n,e={}){const{turnConfigUrl:t}=e;return{connectWrtc:async(r,a)=>{const o=await fetch(n,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({offer:r,wrtcParams:a})});if(!o.ok){const i=await o.text().catch(()=>"");throw new Error(`Proxy request failed (${o.status}): ${i}`)}return await o.json()},getIceServers:t?async()=>{try{const r=await fetch(t,{method:"GET",headers:{"Content-Type":"application/json"}});return r.ok?(await r.json()).iceServers||null:(console.warn(`[RFWebRTC] Failed to fetch TURN config from proxy (${r.status})`),null)}catch(r){return console.warn("[RFWebRTC] Error fetching TURN config from proxy:",r),null}}:void 0}}};async function V(n={video:!0}){try{console.log("[RFStreams] requesting with",n);const e=await navigator.mediaDevices.getUserMedia(n);return console.log("[RFStreams] got stream",e.getVideoTracks().map(t=>({id:t.id,label:t.label}))),e}catch(e){console.warn("[RFStreams] failed, falling back",e);const t=await navigator.mediaDevices.getUserMedia({video:!0,audio:!1});return console.log("[RFStreams] fallback stream",t.getVideoTracks().map(r=>({id:r.id,label:r.label}))),t}}function I(n){n&&(n.getTracks().forEach(e=>e.stop()),console.log("[RFStreams] Stream stopped"))}const $=Object.freeze(Object.defineProperty({__proto__:null,stopStream:I,useCamera:V},Symbol.toStringTag,{value:"Module"})),F=49152,M=262144,z=10;function H(n){return new Promise(e=>setTimeout(e,n))}class L{constructor(e,t){l(this,"file");l(this,"channel");l(this,"totalChunks");l(this,"cancelled",!1);this.file=e,this.channel=t,this.totalChunks=Math.ceil(e.size/F)}cancel(){this.cancelled=!0}async upload(e){const t=this.file.size;for(let r=0;r<this.totalChunks;r++){if(this.cancelled)throw new Error("Upload cancelled");if(this.channel.readyState!=="open")throw new Error("Video upload interrupted");const a=r*F,o=Math.min(a+F,t),i=this.file.slice(a,o),f=new Uint8Array(await i.arrayBuffer()),d=new ArrayBuffer(8+f.length),c=new DataView(d);for(c.setUint32(0,r,!0),c.setUint32(4,this.totalChunks,!0),new Uint8Array(d,8).set(f);this.channel.bufferedAmount>M;){if(this.channel.readyState!=="open")throw new Error("Video upload interrupted");await H(z)}this.channel.send(d),e&&e(o,t)}}}const J=12;class O{constructor(){l(this,"pendingFrames",new Map)}processChunk(e,t,r,a){if(r===1)return a;this.pendingFrames.has(e)||this.pendingFrames.set(e,{chunks:new Map,totalChunks:r});const o=this.pendingFrames.get(e);if(o.chunks.set(t,a),o.chunks.size===r){const i=Array.from(o.chunks.values()).reduce((c,s)=>c+s.length,0),f=new Uint8Array(i);let d=0;for(let c=0;c<r;c++){const s=o.chunks.get(c);f.set(s,d),d+=s.length}return this.pendingFrames.delete(e),f}return null}clear(){this.pendingFrames.clear()}}function D(n){const e=new DataView(n),t=e.getUint32(0,!0),r=e.getUint32(4,!0),a=e.getUint32(8,!0),o=new Uint8Array(n,J);return{frameId:t,chunkIndex:r,totalChunks:a,payload:o}}async function G(n,e=6e3){if(n.iceGatheringState==="complete")return;let t=!1;const r=a=>{a.candidate&&a.candidate.type==="srflx"&&(t=!0)};n.addEventListener("icecandidate",r);try{await Promise.race([new Promise(a=>{const o=()=>{n.iceGatheringState==="complete"&&(n.removeEventListener("icegatheringstatechange",o),a())};n.addEventListener("icegatheringstatechange",o)}),new Promise((a,o)=>{setTimeout(()=>{t?a():(console.error("[ICE] timeout with NO srflx candidate! Connection may fail."),o(new Error("ICE gathering timeout without srflx candidate")))},e)})])}finally{n.removeEventListener("icecandidate",r)}}function Z(n){return new Promise(e=>{n.addEventListener("track",t=>{t.streams&&t.streams[0]&&e(t.streams[0])})})}const Q=[{urls:["stun:stun.l.google.com:19302"]}];async function X(n,e,t,r,a){if([!!n,!!e,!!r].filter(Boolean).length!==1)throw new Error("Exactly one of localStream, file, or rtspUrl must be provided");const c=t??Q,s=new RTCPeerConnection({iceServers:c});a!=null&&a.onPeerConnectionCreated&&await a.onPeerConnectionCreated(s);try{s.addTransceiver("video",{direction:"recvonly"})}catch(p){console.warn("[RFWebRTC] Could not add transceiver:",p)}if(n)for(const p of n.getVideoTracks()){const R=s.addTrack(p,n);a!=null&&a.onTrackAdded&&await a.onTrackAdded(p,R,s)}const C=Z(s),v=s.createDataChannel("inference",{ordered:!0});let m;e&&(m=s.createDataChannel("video_upload"));let u=await s.createOffer();if(a!=null&&a.onOfferCreated){const p=await a.onOfferCreated(u);p&&(u=p)}return await s.setLocalDescription(u),await G(s),{pc:s,offer:s.localDescription,remoteStreamPromise:C,dataChannel:v,uploadChannel:m}}async function Y(n){const e=n.getSenders().find(r=>r.track&&r.track.kind==="video");if(!e)return;const t=e.getParameters();t.encodings=t.encodings||[{}],t.encodings[0].scaleResolutionDownBy=1;try{await e.setParameters(t)}catch(r){console.warn("[RFWebRTC] Failed to set encoding parameters:",r)}}function ee(n,e=3e4){return new Promise((t,r)=>{if(n.readyState==="open"){t();return}const a=()=>{n.removeEventListener("open",a),n.removeEventListener("error",o),clearTimeout(i),t()},o=()=>{n.removeEventListener("open",a),n.removeEventListener("error",o),clearTimeout(i),r(new Error("Datachannel error"))},i=setTimeout(()=>{n.removeEventListener("open",a),n.removeEventListener("error",o),r(new Error("Datachannel open timeout"))},e);n.addEventListener("open",a),n.addEventListener("error",o)})}class N{constructor(e,t,r,a,o,i){l(this,"peerConnection");l(this,"_localStream");l(this,"remoteStreamPromise");l(this,"pipelineId");l(this,"apiKey");l(this,"dataChannel");l(this,"reassembler");l(this,"ackPacingEnabled");l(this,"uploadChannel");l(this,"uploader");l(this,"onComplete");this.peerConnection=e,this._localStream=i==null?void 0:i.localStream,this.remoteStreamPromise=t,this.pipelineId=r,this.apiKey=a,this.dataChannel=o,this.reassembler=new O,this.ackPacingEnabled=(i==null?void 0:i.ackPacingEnabled)===!0,this.uploadChannel=i==null?void 0:i.uploadChannel,this.onComplete=i==null?void 0:i.onComplete,this.dataChannel.binaryType="arraybuffer";const f=i==null?void 0:i.onData;f&&(this.dataChannel.addEventListener("message",d=>{try{if(d.data instanceof ArrayBuffer){const{frameId:c,chunkIndex:s,totalChunks:C,payload:v}=D(d.data),m=this.reassembler.processChunk(c,s,C,v);if(m){const p=new TextDecoder("utf-8").decode(m),R=JSON.parse(p);Promise.resolve(f(R)).finally(()=>{this.maybeSendAck(c)})}}else{const c=JSON.parse(d.data);f(c)}}catch(c){console.error("[RFWebRTC] Failed to parse data channel message:",c)}}),this.dataChannel.addEventListener("error",d=>{console.error("[RFWebRTC] Data channel error:",d)})),this.dataChannel.addEventListener("close",()=>{this.reassembler.clear(),this.onComplete&&this.onComplete()})}maybeSendAck(e){this.ackPacingEnabled&&this.dataChannel.readyState==="open"&&this.dataChannel.send(JSON.stringify({ack:e}))}async remoteStream(){return await this.remoteStreamPromise}localStream(){return this._localStream}async cleanup(){if(this.uploader&&this.uploader.cancel(),this.reassembler.clear(),this.pipelineId&&this.apiKey)try{await T.init({apiKey:this.apiKey}).terminatePipeline({pipelineId:this.pipelineId})}catch(e){console.warn("[RFWebRTC] Failed to terminate pipeline:",e)}this.peerConnection&&this.peerConnection.connectionState!=="closed"&&this.peerConnection.close(),this._localStream&&I(this._localStream)}async startUpload(e,t){if(!this.uploadChannel)throw new Error("No upload channel available. This connection was not created for file uploads.");await ee(this.uploadChannel),this.uploader=new L(e,this.uploadChannel),await this.uploader.upload(t)}cancelUpload(){this.uploader&&this.uploader.cancel()}reconfigureOutputs(e){const t={};e.streamOutput!==void 0&&(t.stream_output=e.streamOutput),e.dataOutput!==void 0&&(t.data_output=e.dataOutput),this.sendData(t)}sendData(e){if(this.dataChannel.readyState!=="open"){console.warn("[RFWebRTC] Data channel is not open. Current state:",this.dataChannel.readyState);return}try{const t=typeof e=="string"?e:JSON.stringify(e);this.dataChannel.send(t)}catch(t){console.error("[RFWebRTC] Failed to send data:",t)}}}async function U({source:n,rtspUrl:e,connector:t,wrtcParams:r,onData:a,onComplete:o,onFileUploadProgress:i,options:f={},hooks:d}){var q;if(!t||typeof t.connectWrtc!="function")throw new Error("connector must have a connectWrtc method");const c=!!e,s=!c&&n instanceof File,C=!c&&!s&&n?n:void 0,v=s?n:void 0;let m=r.iceServers;if((!m||m.length===0)&&t.getIceServers)try{const S=await t.getIceServers();S&&S.length>0&&(m=S,console.log("[RFWebRTC] Using TURN servers from connector"))}catch(S){console.warn("[RFWebRTC] Failed to fetch TURN config, using defaults:",S)}const{pc:u,offer:p,remoteStreamPromise:R,dataChannel:P,uploadChannel:E}=await X(C,v,m,e,d),b={...r,iceServers:m,realtimeProcessing:r.realtimeProcessing??!s,rtspUrl:e},g=await t.connectWrtc({sdp:p.sdp,type:p.type},b),y={sdp:g.sdp,type:g.type};if(!(y!=null&&y.sdp)||!(y!=null&&y.type))throw console.error("[RFWebRTC] Invalid answer from server:",g),new Error("connector.connectWrtc must return answer with sdp and type");const x=((q=g==null?void 0:g.context)==null?void 0:q.pipeline_id)||null;await u.setRemoteDescription(y),await new Promise((S,j)=>{const k=()=>{u.connectionState==="connected"?(u.removeEventListener("connectionstatechange",k),S()):u.connectionState==="failed"&&(u.removeEventListener("connectionstatechange",k),j(new Error("WebRTC connection failed")))};u.addEventListener("connectionstatechange",k),k(),setTimeout(()=>{u.removeEventListener("connectionstatechange",k),j(new Error("WebRTC connection timeout after 30s"))},3e4)}),C&&f.disableInputStreamDownscaling!==!1&&await Y(u);const W=t._apiKey||null,ie=b.realtimeProcessing===!1,B=new N(u,R,x,W,P,{localStream:C,uploadChannel:E,onData:a,onComplete:o,ackPacingEnabled:ie});return v&&E&&B.startUpload(v,i).catch(S=>{console.error("[RFWebRTC] Upload error:",S)}),B}async function te({source:n,connector:e,wrtcParams:t,onData:r,options:a={},hooks:o}){if(n instanceof File)throw new Error("useStream requires a MediaStream. Use useVideoFile for File uploads.");return U({source:n,connector:e,wrtcParams:t,onData:r,options:a,hooks:o})}async function re({file:n,connector:e,wrtcParams:t,onData:r,onUploadProgress:a,onComplete:o,hooks:i}){return U({source:n,connector:e,wrtcParams:{...t,realtimeProcessing:t.realtimeProcessing??!0},onData:r,onComplete:o,onFileUploadProgress:a,hooks:i})}async function ne({rtspUrl:n,connector:e,wrtcParams:t,onData:r,hooks:a}){if(!n.startsWith("rtsp://")&&!n.startsWith("rtsps://"))throw new Error("Invalid RTSP URL: must start with rtsp:// or rtsps://");return U({rtspUrl:n,connector:e,wrtcParams:t,onData:r,hooks:a})}const ae=Object.freeze(Object.defineProperty({__proto__:null,ChunkReassembler:O,FileUploader:L,RFWebRTCConnection:N,parseBinaryHeader:D,useRtspStream:ne,useStream:te,useVideoFile:re},Symbol.toStringTag,{value:"Module"}));h.InferenceHTTPClient=T,h.connectors=K,h.streams=$,h.webrtc=ae,Object.defineProperty(h,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=index.js.map
